# 进程与线程

## 基本概念

进程：计算机上所有可以运行的软件。

导致进程创建的4个原因：
- 系统初始化
- 正在运行的程序执行了创建进程的系统调用
- 用户请求创建一个新进程
- 一个批处理作业的初始化

停留在后台处理活动的进程叫守护进程。

在UNIX系统中，只有一个系统调用可以用来创建新进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用了fork后，这两个进程（父进程和子进程）拥有相同的内存映像，同样的环境字符串和同样的打开文件。

详见[fork](./Fork.md)

进程终止主要由下列原因引起：
- 正常退出
- 出错退出
- 严重错误
- 被其他进程杀死

进程的三种状态：运行态，就绪态，阻塞态。

![](https://i0.hdslb.com/bfs/album/265a5d18e390eea345be4bf4fe7af68d70680536.png)

1. 进程因为等待输入而被阻塞
2. 调度程序选择另一个进程
3. 调度程序选择这个进程
4. 出现有效输入

中断发生后操作系统最底层的工作步骤：
- 硬件压入堆栈程序计数器等
- 硬件从中断向量装入新的程序计数器
- 汇编语言过程保存寄存器值
- 汇编语言过程设置新的堆栈
- C中断服务例程运行
- 调度程序决定下一个将运行的进程
- C过程返回至汇编代码
- 汇编语言过程开始运行新的当前进程

## 进程间通信

### 生产者消费者问题

两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区。另一个是消费者，从缓冲区中取出消息。
问题在于当缓冲区已经满了，而此时生产者还想向其中放入一个数据项的情况。其解决办法是让生产者睡眠，待消费者从缓冲区中取出一个或多个数据项时再唤醒它。当消费者试图从缓冲区中取数据而发现缓冲区为空时，消费者就睡眠，直到生产者向其中放入一些数据时再将其唤醒。

解决方式待填坑

### 管程

管程封装了共享变量以及一些对共享变量的操作。

打一个相对形象的比喻：人们到一家叫做计算机的银行取钱，这个银行里面就一个空窗口。最早之前，每个人需要从这个窗口爬进去取钱。这里，银行里面每一个需要取钱的人看作进程，而银行里面的钱可以看做计算机的共享资源，一般是硬件设备或一群共享变量。每个人都向窗口拥挤，场面混乱不堪。后面计算机银行不断改进，发明了一种叫ATM的机器（管程），ATM（管程）封装了钱和对外开放了一些存取钱的操作。这样一来，ATM（管程）在计算机银行的钱和客户之间担任了中介服务的角色。在一个相对封闭的屋子里面，一次只能服务一个人（让进程互斥使用）。ATM屋子里面有人的时候，其他需要依次排队使用。一个人（进程）在ATM使用的时间太长也不行，所以需要一个条件变量（condition）来约束他。条件变量可以让一个线程等待时让另一线程进入管程，这样可以有效防止死锁。

以上引用自[应该如何理解管程？](https://juejin.cn/post/7022942510247280670)

操作系统本身不支持monitor机制，一般的实现是编译器层面上的实现。在使用时需要几个元素来配合：临界区，monitor对象及锁，条件变量以及定义在monitor对象上的wait，signal操作。
使用monitor机制的目的的主要是为了互斥进入临界区，为了做到能够阻塞无法进入临界区的进程/线程，还需要一个monitor object来协助，此外由于monitor机制本质上是基于mutex基本原语的，所以还需要维护一个基于mutex的锁。而且为了在适当的时候能阻塞和唤醒进程（线程）还需要引入一个条件变量。

详见synchronized的实现原理。

